## 4-1 vue原理

原理：
	
	组件化MVVM
	响应式
	vdom,diff
	模板编译
	组件渲染过程
	前端路由

## 4-2 组件化基础

很久之前就有组件化

asp、jsp、php 已经有组件化了
 
传统组件，只是静态渲染，更新还需要依赖于操作 DOM   
数据驱动视图，vue MVVM  
数据驱动视图，react setState  

[!img](https://upload-images.jianshu.io/upload_images/13119656-40e070c90fe8f861.png?imageMogr2/auto-orient/strip|imageView2/2/w/758/format/webp)

## 4-3、4-4 数据监听

如何起一个服务？  
在目标文件夹下：  

```
npm i http-server -g   
http-server -p 8001  

// 一级监听
function defineReactive(target, key, value) {
    // 核心 API
    Object.defineProperty(target, key, {
        get() {
            return value
        },
        set(newValue) {
            if (newValue !== value) {
                // 设置新值
                // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值
                value = newValue

                // 触发更新视图
                updateView()
            }
        }
    })
}

// 深度监听
function defineReactive(target, key, value) {
    // 深度监听
    observer(value)

    // 核心 API
    Object.defineProperty(target, key, {
        get() {
            return value
        },
        set(newValue) {
            if (newValue !== value) {
                // 深度监听
                observer(newValue)

                // 设置新值
                // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值
                value = newValue

                // 触发更新视图
                updateView()
            }
        }
    })
}
```

深度监听和 普通监听的区别：  
变化，在 设置新值 和 对每个属性 value 进行 observer 函数



缺点：

	监听对象的属性，如果属性还是对象，需要深度监听，而且是递归
	无法监听新增、删除属性
		如果data 添加了新的属性，是无法监听到的，需要使用 Vue.set
		无法监听 delete data 中的属性, Vue.delete
	无法原生监听数组，需要特殊处理
	
	
## 4-5 监听数组变化
 
 	需要对监听的数组，做深拷贝
 	
 	```
 	// 如果是数组，原型指向定义的 数组
 	if (Array.isArray(target)) {
        target.__proto__ = arrProto
    }
 	
 	
 	// arrProto 类的数组，有啥特点
 	const oldArrayProperty = Array.prototype
 	
	// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型
	
	const arrProto = Object.create(oldArrayProperty);
	
	['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName => {
    arrProto[methodName] = function () {
        updateView() // 触发视图更新
        oldArrayProperty[methodName].call(this, ...arguments)
        
        // Array.prototype.push.call(this, ...arguments)
        
    }
})
	```
	

## 4-6、4-7 虚拟dom, virtual dom


dom操作非常消耗性能  
以前用jQuery，可以自行控制Dom 操作的时机，手动调整  
vue 和 react 是数据驱动视图，如何有效控制dom 操作？  


把对dom的操作转移为对js的计算，因为js执行速度很快  
使用js模拟dom结构，计算出最小的变更，操作dom  

使用js对象模拟dom结构

```
{
tag: 'div',
props: {
	className: 'container',
	id: 'div1'
}
children: [{
		tag: 'p',
		children: 'vdom'
	},
	{
		tag: 'ul',
		props: {style: 'font-size: 20px'},
		children: [
			{
				tag: 'li',
				children: 'a'
			}
		]
	}
]
}
```

## 4-8 diff 算法
	
树的diff 时间复杂度是 O(n^3)

 算法如何优化到O(n)
 	
 	1. 只比较同一层级，不跨级比较
 	2. tag不相同，则直接删掉重建，不再深度比较
 	3. tag 和 key, 两者都相同，则认为是相同节点，不再深度比较

	

## 4-9、10、11、12 深入 diff 算法

//sel: string || undefined
//key: data.key || undefined

var vnode = h(sel, data, children, text, ele, key)

patch(container, vnode)

var newVnode = h()
patch(vnode, newVnode)















